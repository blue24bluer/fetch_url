from flask import Flask, request, jsonify, Response, stream_with_context
import yt_dlp
import json
import os
import tempfile
import subprocess
import shutil

app = Flask(__name__)

FFMPEG_BIN = shutil.which("ffmpeg") or "ffmpeg"

def json_cookies_to_netscape(json_path):
    if not os.path.exists(json_path): return None
    try:
        with open(json_path, 'r', encoding='utf-8') as f: cookies = json.load(f)
        fd, temp_path = tempfile.mkstemp(suffix='.txt', text=True)
        with os.fdopen(fd, 'w', encoding='utf-8') as f:
            f.write("# Netscape HTTP Cookie File\n# Generated by Server\n\n")
            for c in cookies:
                domain, name, value = c.get('domain'), c.get('name'), c.get('value', '')
                if not domain or not name: continue
                flag = 'TRUE' if domain.startswith('.') else 'FALSE'
                path = c.get('path', '/')
                secure = 'TRUE' if c.get('secure') else 'FALSE'
                expiry = int(c.get('expirationDate', c.get('expiry', 0)) or 0)
                f.write(f"{domain}\t{flag}\t{path}\t{secure}\t{expiry}\t{name}\t{value}\n")
        return temp_path
    except Exception as e:
        print(f"Cookie Error: {e}"); return None

# ====================
# [API] Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø³Ø±ÙŠØ¹
# ====================
@app.route('/api/search', methods=['GET'])
def search_youtube():
    query = request.args.get('q')
    limit = request.args.get('limit', '5')
    if not query: return jsonify({'error': 'Missing query'}), 400

    cookie_file = json_cookies_to_netscape('youtube.json')
    
    # ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø³Ø±Ø¹Ø©: ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¬Ù„ÙˆØ¨Ø©
    ydl_opts = {
        'quiet': True, 'no_warnings': True, 'cookiefile': cookie_file,
        'extract_flat': True,  # âš¡ Ø³Ø±Ø¹Ø© ÙØ§Ø¦Ù‚Ø© (Ù„Ø§ ÙŠØ¬Ù„Ø¨ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© Ø§Ù„Ø¢Ù†)
        'http_headers': {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/90.0.4430.212 Safari/537.36'}
    }

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            res = ydl.extract_info(f"ytsearch{limit}:{query}", download=False)
            entries = res.get('entries', [])
            
            clean_results = []
            for item in entries:
                if not item: continue
                # ØªÙƒÙˆÙŠÙ† Ø§Ù„Ø±Ø§Ø¨Ø· ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù„Ù„Ø³Ø±Ø¹Ø© Ø¨Ø¯Ù„ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ÙØ­Øµ
                vid_url = item.get('url') if 'url' in item else f"https://www.youtube.com/watch?v={item['id']}"
                
                clean_results.append({
                    'title': item.get('title', 'Unknown'),
                    'url': vid_url,
                    'duration': item.get('duration', 0),
                    'uploader': item.get('uploader', 'Unknown')
                })
                
        if cookie_file and os.path.exists(cookie_file): os.unlink(cookie_file)
        return jsonify({'count': len(clean_results), 'results': clean_results})

    except Exception as e:
        if cookie_file and os.path.exists(cookie_file): os.unlink(cookie_file)
        return jsonify({'error': str(e)}), 500

# ==============================
# [API] Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³Ù„Ø³ (Direct Pipe)
# ==============================
@app.route('/api/download', methods=['GET'])
def download_stream():
    url = request.args.get('url')
    m_type = request.args.get('type', 'video') # audio, video
    q_req = request.args.get('q', '720')
    out_fmt = request.args.get('fmt', 'mp4') # mp4, mp3
    
    if not url: return jsonify({'error': 'URL missing'}), 400
    
    cookie_file = json_cookies_to_netscape('youtube.json')

    # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (Raw Stream URL)
    ydl_opts = {
        'quiet': True, 'no_warnings': True, 'cookiefile': cookie_file,
        'http_headers': {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/90.0.4430.212 Safari/537.36'}
    }
    
    # Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¬ÙˆØ¯Ø© Ø¨Ø¯Ù‚Ø©
    if m_type == 'audio':
        # Ù†Ø·Ù„Ø¨ Ø£ÙØ¶Ù„ ØµÙˆØª Ø¨ØµÙŠØºØ© m4a Ù„Ø³Ù‡ÙˆÙ„Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„
        ydl_opts['format'] = 'bestaudio[ext=m4a]/bestaudio'
    else:
        # Ù„Ù„ÙÙŠØ¯ÙŠÙˆ Ù†Ø·Ù„Ø¨ Ø±Ø§Ø¨Ø· ÙˆØ§Ø­Ø¯ Ù…Ø¯Ù…Ø¬ (Ù„ØªØ¬Ù†Ø¨ Ø¯Ù…Ø¬ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙˆØ§Ù„ØµÙˆØª Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…)
        # Ù‡Ø°Ø§ Ø£Ø³Ø±Ø¹ Ø¨ÙƒØ«ÙŠØ± Ù„Ø£Ù† yt-dlp Ù„Ø§ ÙŠØ­ØªØ§Ø¬ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ffmpeg Ù„Ù„Ø¯Ù…Ø¬
        if q_req == 'best':
            ydl_opts['format'] = 'best'
        else:
            try: h = int(q_req)
            except: h = 720
            # Ù†Ø·Ù„Ø¨ ÙÙŠØ¯ÙŠÙˆ Ø¨ØµÙŠØºØ© mp4 ÙˆØ¬Ø§Ù‡Ø² (pre-merged) Ø¨Ø§Ø±ØªÙØ§Ø¹ Ù…Ø¹ÙŠÙ†
            ydl_opts['format'] = f"best[ext=mp4][height<={h}]/best[ext=mp4]/best"

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            stream_url = info.get('url') # Ø±Ø§Ø¨Ø· Ø¬ÙˆØ¬Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
            title = info.get('title', 'downloaded_file')
            
            # ÙÙŠ Ø¨Ø¹Ø¶ Ø§Ù„Ø­Ø§Ù„Ø§Øª Ø§Ù„Ù†Ø§Ø¯Ø±Ø© Ù‚Ø¯ Ù„Ø§ Ù†Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ù…Ø¨Ø§Ø´Ø±ØŒ Ù†Ø¹ÙŠØ¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨ØµÙŠØºØ© Ø¹Ø§Ù…Ø©
            if not stream_url:
                stream_url = info['formats'][-1]['url']

    except Exception as e:
        if cookie_file: os.unlink(cookie_file)
        return jsonify({'error': f"Extractor Error: {str(e)}"}), 500

    if cookie_file: os.unlink(cookie_file)

    # ğŸš€ Ù‡Ù†Ø§ Ø§Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ø¬ÙˆÙ‡Ø±ÙŠ: Stream Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø± Ù„Ù€ ffmpeg Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¨Ø§Ø´Ø±Ø©
    # Ù†Ø³ØªØ®Ø¯Ù… pipe:1 Ù„Ù„Ø¥Ø¬Ø¨Ø§Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¯ÙØ¹ Ø§Ù„ÙÙˆØ±ÙŠ
    ffmpeg_cmd = [
        FFMPEG_BIN, '-y',
        '-headers', 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/90.0.4430.212 Safari/537.36\r\n',
        '-i', stream_url, # Ø§Ù„Ø¯Ø®Ù„ Ù‡Ùˆ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
        '-c', 'copy',     # Ù†Ø³Ø® Ø¨Ø¯ÙˆÙ† Ø¥Ø¹Ø§Ø¯Ø© ØªØ±Ù…ÙŠØ² (Ø³Ø±Ø¹Ø© Ø®Ø§Ø±Ù‚Ø©)
        '-f', 'mp4'       # Ø§Ù„Ø­Ø§ÙˆÙŠØ©
    ]

    # Ø¶Ø¨Ø· Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹ (Ø¨Ø£Ø³Ø±Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ù…ÙƒÙ†Ø©)
    final_filename = f"{title}.mp4"
    mime_type = "video/mp4"

    if m_type == 'audio':
        # Ù„Ù„ØµÙˆØª: Ù†Ø­ÙˆÙ„ Ø¨Ø³Ø±Ø¹Ø© Ø¥Ù„Ù‰ mp3 Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ù‚Ù„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¬ÙˆØ¯Ø© Ù…Ù‚Ø¨ÙˆÙ„Ø© Ù„Ù„Ø³Ø±Ø¹Ø©
        # -q:a 4 ØªØ¹Ù†ÙŠ Ø¬ÙˆØ¯Ø© Ù…ØªÙˆØ³Ø·Ø©/Ø¹Ø§Ù„ÙŠØ© Ù„ÙƒÙ† Ø³Ø±ÙŠØ¹Ø©
        ffmpeg_cmd = [
            FFMPEG_BIN, '-y',
            '-i', stream_url,
            '-vn', # Ø­Ø°Ù Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
            '-acodec', 'libmp3lame', '-q:a', '4', 
            '-f', 'mp3'
        ]
        final_filename = f"{title}.mp3"
        mime_type = "audio/mpeg"
        out_fmt = "mp3"
    
    else:
        # Ù„Ù„ÙÙŠØ¯ÙŠÙˆ: ÙŠØ¬Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… frag_keyframe Ù„Ù„Ø¨Ø« Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (Streaming) Ø¹Ø¨Ø± HTTP
        # ÙˆØ¥Ù„Ø§ Ø³ÙŠÙ†ØªØ¸Ø± ffmpeg Ø­ØªÙ‰ ÙŠÙ†ØªÙ‡ÙŠ Ø§Ù„Ù…Ù„Ù Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ù„ÙŠÙƒØªØ¨ Ø§Ù„Ù€ header
        ffmpeg_cmd = [
            FFMPEG_BIN, '-y',
            '-i', stream_url,
            '-c', 'copy',
            '-movflags', 'frag_keyframe+empty_moov', # âš¡ Ø§Ù„Ø³Ø­Ø± Ù‡Ù†Ø§ (ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªØ­Ù…ÙŠÙ„ ÙÙˆØ±Ø§Ù‹)
            '-f', 'mp4'
        ]

    ffmpeg_cmd.append('-') # Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ Ù„Ù„Ù€ Stdout

    # ØªÙ†Ø¸ÙŠÙ Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù
    safe_name = "".join([c for c in final_filename if c.isalnum() or c in "._- "]).strip()
    if not safe_name: safe_name = f"download.{out_fmt}"

    # Ø¯Ø§Ù„Ø© Ø§Ù„Ù…ÙˆÙ„Ø¯ (Generator)
    def stream_ffmpeg():
        # bufsize=0 Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ Ù„Ø¹Ø¯Ù… Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
        process = subprocess.Popen(
            ffmpeg_cmd, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE, 
            bufsize=0  
        )
        
        try:
            # Ù‚Ø±Ø§Ø¡Ø© Ù‚Ø·Ø¹ ØµØºÙŠØ±Ø© (4KB) ÙˆØ¥Ø±Ø³Ø§Ù„Ù‡Ø§ ÙÙˆØ±Ø§Ù‹
            while True:
                chunk = process.stdout.read(4096)
                if not chunk: break
                yield chunk
        except GeneratorExit:
            process.kill()
        finally:
            if process.poll() is None: process.terminate()

    return Response(
        stream_with_context(stream_ffmpeg()),
        mimetype=mime_type,
        headers={
            "Content-Disposition": f'attachment; filename="{safe_name}"',
            # headers Ù„Ù…Ù†Ø¹ Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª ÙÙŠ Ø§Ù„Ø·Ø±ÙŠÙ‚ (Nginx/Proxy)
            "X-Accel-Buffering": "no",
            "Cache-Control": "no-cache"
        }
    )

if __name__ == '__main__':
    # Threaded=True Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø·Ù„Ø¨Ø§Øª Ù…ØªØ²Ø§Ù…Ù†Ø©
    app.run(host='0.0.0.0', port=5000, threaded=True)
